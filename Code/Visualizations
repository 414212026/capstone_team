import pandas as pd 
import numpy as np
import altair as alt
import vega_datasets
from vega_datasets import data
from datetime import datetime
import yfinance as yahooFinance

alt.data_transformers.disable_max_rows()
alt.data_transformers.disable_max_rows()

## Prep for Visualizations

start_date = "2022-03-01"
end_date = "2024-11-22"
tickers=['AVGO','IBM','ORCL','CRM','TSLA','COF','GS','NVDA','NKE','GM']

#Functions to pull stock data

def fetch_and_process_stock_data(symbol, start, end):
    df = yf.download(symbol, start=start, end=end)
    df.index = pd.to_datetime(df.index)
    df.index = df.index.strftime('%Y-%m-%d')
    df['Adj_Closed_price'] = df['Adj Close']
    df['Closed_price'] = df['Close']
    df['Open_price'] = df['Open']
    df['Log_Return'] = np.log(df['Adj_Closed_price'] / df['Adj_Closed_price'].shift(1))
    df['Adj_Open_price'] = df['Open_price'] * (df['Adj_Closed_price'] / df['Closed_price'])
    # only use Next_day_Adj_Open_price for measurement, drop it for model building to prevent data leakage
    df['Next_day_Adj_Open_price'] = df['Adj_Open_price'].shift(-1)
    df_result = df[['Adj_Closed_price','Log_Return','Next_day_Adj_Open_price']].copy()
    df_result = df_result.reset_index().rename(columns={'index': 'Date'})
    return df_result
    
def download_stock_data(tickers, start_date, end_date):
    stock_data=[]
    for ticker in tickers:
        data=fetch_and_process_stock_data(ticker, start_date, end_date)
        data['Ticker']=ticker
        stock_data.append(data)
    return pd.concat(stock_data,axis=0)

def add_technical_indicators(df):
    # # Moving Averages based on Adjusted Close
    df['ma_10'] = df['Adj_Closed_price'].rolling(window=10).mean()
    df['ma_30'] = df['Adj_Closed_price'].rolling(window=30).mean()
    # # Exponential Moving Average based on Adjusted Close
    df['ema_10'] = df['Adj_Closed_price'].ewm(span=10, adjust=False).mean()
    # # Volatility - Standard Deviation of log returns
    df['volatility_10'] = df['Log_Return'].rolling(window=10).std()
    # # Relative Strength Index (RSI) based on Adjusted Close
    delta = df['Adj_Closed_price'].diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    df['rsi_14'] = 100 - (100 / (1 + rs))
    # # Fill NaN values with previous values or a constant if needed
    df = df.ffill().fillna(0)
    return df

#Defining variables
tickers=['AVGO','IBM','ORCL','CRM','TSLA','COF','GS','NVDA','NKE','GM']

#Downloading data
stock_download=download_stock_data(tickers, start_date, end_date)
stock_df_sep=[]
for ticker in tickers:
    temp_data=stock_download[stock_download['Ticker']==ticker].copy()
    stock_df_sep.append(add_technical_indicators(temp_data))

stock_df=pd.concat(stock_df_sep, axis=0)
stock_df.reset_index(inplace=True)
stock_df['Date']= pd.to_datetime(stock_df['Date'])
stock_df['Days_From_Today']=stock_df.groupby('Ticker').cumcount(ascending=False)

vix_df=download_stock_data(['%5EVIX'], start_date, end_date)
vix_df.reset_index(inplace=True)
vix_df['Date']= pd.to_datetime(vix_df['Date'])

# VIX Bins and Corresponding Emojis
vix_cutoffs=[0,15,20,25,30,300]
vix_emojis=['ðŸ˜´','ðŸ™„','ðŸ«£','ðŸ«¨','ðŸ˜±']
vix_df['VIX Emoji'] = pd.cut(vix_df['Adj_Closed_price'], bins=vix_cutoffs, labels=vix_emojis, right=False)

# Merged stock_df with vix_df on Date
merged_df = pd.merge(stock_df, vix_df[['Date','VIX Emoji','Adj_Closed_price']], on='Date', how='left')
merged_df = merged_df.rename(columns={'Adj_Closed_price_y': 'VIX Closing Price'})




## First Visualization (Altair)
# Defined date slider that adjusts based on days from today
date_slider = alt.binding_range(
    name="Days from Today: ",
    min=stock_df['Days_From_Today'].min()+7,
    max=stock_df['Days_From_Today'].max(),
    step=1
)

# Selection for date_slider
date_select = alt.selection_point(
    bind=date_slider,
    fields=['Days_From_Today'],
    value=stock_df['Days_From_Today'].min()+7
)

# Defined ticker symbol drop-down 
ticker_dropdown = alt.binding_select(
    options =  stock_list+[None],
    labels =  stock_list+['All Stocks'],
    name = "Ticker Symbol"
)

# Created selection for ticker_dropdown
ticker_select = alt.selection_point(
    bind=ticker_dropdown,
    fields=['Ticker'],
    value='AVGO'
)

# Created top chart that shows stock closing prices
base = alt.Chart(stock_df).mark_line().encode(
    x='Date:T',
    y=alt.Y('Adj_Closed_price:Q', title='Adjusted Closing Price'),
    color=alt.condition(
        "datum.Days_from_Today <= 3",  
        alt.value('red'),         
        alt.value('steelblue')  
    ),
    tooltip=['Ticker:N','Date:T', 'Adj_Closed_price:Q']
).properties(width=500, height=200)

# Bottom chart that shows stock's volatility and VIX indicators
base1 = alt.Chart(merged_df).mark_line().encode(
    x='Date:T',
    y=alt.Y('volatility_10:Q', title='Volatility'),
    color=alt.condition(
        "datum.Days_from_Today <= 3", 
        alt.value('red'),       
        alt.value('steelblue')  
    ),
    tooltip=['Ticker:N','Date:T',alt.Tooltip('volatility_10:Q',format='.2f'), 'VIX Emoji:N']
).properties(width=500, height=200)

# Apply filters to the charts based on the selected ticker and date
filtered_base = (base).add_params(ticker_select, date_select).transform_filter(
    ticker_select).transform_filter(
    alt.datum.Days_From_Today <= date_select['Days_From_Today']
)



filtered_base1 = base1.add_params(ticker_select, date_select).transform_filter(
    ticker_select
).transform_filter(
    alt.datum.Days_From_Today <= date_select['Days_From_Today']
)

# Combine the two charts vertically
final_charts = alt.vconcat(filtered_base, filtered_base1).resolve_scale(
    y='independent'
)

final_charts




## Second Visualization (Plotly)
import plotly.graph_objects as go

## Charles, you need to update the news_sent_df + list_sent with the financial news data you have

news_sent_df=pd.concat(list_sent,axis=0)
news_sent_df.set_index(['date'],inplace=True)
news_sent_df['Total Count']=np.sum(news_sent_df[['Bearish Count','Bullish Count','Neutral Count','Somewhat-Bearish Count','Somewhat-Bullish Count']],axis=1)


#prepping dictionary for Plotly table display
sentiment_for_plot = {
    ticker: {"Metric":
             ["Today", "Yesterday", "Last 3 Days", "Past Week", "Past 2 Weeks"],
            "Average News Sentiment Score": [
                np.round(news_sent_df[news_sent_df['Ticker']==ticker].iloc[-1]['avg_sentiment_score'],2),
                np.round(news_sent_df[news_sent_df['Ticker']==ticker].iloc[-2]['avg_sentiment_score'],2),
                np.round(np.average(news_sent_df[news_sent_df['Ticker']==ticker].iloc[-3:]['avg_sentiment_score']),2),  
                np.round(np.average(news_sent_df[news_sent_df['Ticker']==ticker].iloc[-7:]['avg_sentiment_score']),2),
                np.round(np.average(news_sent_df[news_sent_df['Ticker']==ticker].iloc[-14:]['avg_sentiment_score']),2)
            ],
             "# of News": [
                 news_sent_df[news_sent_df['Ticker']==ticker].iloc[-1]['Total Count'],
                 news_sent_df[news_sent_df['Ticker']==ticker].iloc[-2]['Total Count'],
                 np.sum(news_sent_df[news_sent_df['Ticker']==ticker].iloc[-3:]['Total Count']),
                 np.sum(news_sent_df[news_sent_df['Ticker']==ticker].iloc[-7:]['Total Count']),
                 np.sum(news_sent_df[news_sent_df['Ticker']==ticker].iloc[-14:]['Total Count'])
             ],
            "Mostly": [
                (news_sent_df[news_sent_df['Ticker'] == ticker].iloc[-1].iloc[6:11].idxmax()).split()[0],
                (news_sent_df[news_sent_df['Ticker'] == ticker].iloc[-2].iloc[6:11].idxmax()).split()[0],
                (news_sent_df[news_sent_df['Ticker'] == ticker].iloc[-3:].sum().iloc[6:11].idxmax()).split()[0],
                (news_sent_df[news_sent_df['Ticker'] == ticker].iloc[-7:].sum().iloc[6:11].idxmax()).split()[0],
                (news_sent_df[news_sent_df['Ticker'] == ticker].iloc[-14:].sum().iloc[6:11].idxmax()).split()[0]
            ]
             ]
    
    }
    for ticker in tickers
}

#create chart
fig = go.Figure()

for ticker in tickers:
    fig.add_trace(go.Table(
        header=dict(
                values=["Metric", "Avg. Sentiment Score","# of News Articles","Mostly"],
            fill_color='rgba(0, 128, 128, 0.4)',
            font=dict(size=10),
            align='center'
        ),
        cells=dict(
            values=[sentiment_for_plot[ticker]["Metric"], sentiment_for_plot[ticker]["Average News Sentiment Score"],
                   sentiment_for_plot[ticker]["# of News"], sentiment_for_plot[ticker]["Mostly"]],
            fill_color='white',
            font=dict(size=10),
            align='center'

    )
    ))


buttons = []
for i, ticker in enumerate(tickers):
    visibility = [False] * len(tickers)
    visibility[i] = True
    buttons.append(
        dict(
            label=ticker,
            method="update",
            args=[{"visible": visibility},
                  {"title": f"News Sentiment Scores"}]
        )
    )


fig.update_layout(
    updatemenus=[
        dict(
            type="dropdown",
            direction="down",
            x=0.7,
            y=1.1,
            showactive=True,
            buttons=buttons
        )
    ],
    title="News Sentiment Scores",
    width=500,
    height=500,
    margin=dict(l=20, r=20, t=50, b=20)
)

#Plotting 2nd Visualization
fig.show()


##Third Visualization (Altair) - Will update after Yi finishes modeling
up_arrow = '\u2191'

portfolio_data = {
    'Stock': ['NVDA', 'ORCL','MSFT', 'GOOGL', 'GM', 'TSLA','IBM','GM','JPM','AVGO'],
    'Sector':['Technology','Technology','Technology',
              'Technology','Automotive','Automotive',
              'Financial Services','Technology','Technology',
              'Technology'],
    'Weight': [0.35, 0.17,0.01, 0.20, 0.02, 0.05,0.08, 0.04,0.07,0.1],
    'Return': [23.22,32.01,9.44,3.19,43.00,0.42,103.12,23,333,33]

}
portfolio_df=pd.DataFrame(portfolio_data)

pie_return_chart=alt.Chart(portfolio_df).mark_arc(radius=90,radius2=120).encode(
    theta="Return:Q",
    color="Stock:N",
    tooltip=['Stock:N',alt.Tooltip("Weight:Q", format=".0%"),'Return:Q']
)


total_return_sum = portfolio_df['Return'].sum()  

above_text = alt.Chart(pd.DataFrame({'Total Return': [total_return_sum]})).mark_text(
    baseline="middle",
    dy=-18,
    opacity=0.7
).encode(
    text=alt.value("Total Return"),  # Add your own text
    color=alt.value("black")       # Set text color
)

center_text = alt.Chart(pd.DataFrame({'Total Return': [total_return_sum]})).mark_text(
    align='center',
    baseline='middle',
    fontSize=20
).encode(
    text=alt.Text("Total Return:Q", format="$.2f")
)

below_text = alt.Chart(pd.DataFrame({'Total Return': [total_return_sum]})).mark_text(
    baseline="middle",
    dy=17,
    opacity=0.5
).encode(
    text=alt.value(f"+20{up_arrow}"),  
    color=alt.value("black")     
)


bar_chart1=alt.Chart(portfolio_df).mark_bar().encode(
    y=alt.Y('Stock:N',title=''),
    x=alt.X('Return:Q',title='Return by Stock'),
    color=alt.Color('Stock:N').scale(scheme='tealblues'),
    tooltip=['Stock:N',alt.Tooltip("Return:Q", format="$.2f")]
)

bar_chart2=alt.Chart(portfolio_df).mark_bar().encode(
    y=alt.Y('Sector:N',title=''),
    x=alt.X('Return:Q',title='Return by Sector'),
    color=alt.Color('Stock:N').scale(scheme='tealblues'),
    tooltip=['Stock:N',alt.Tooltip("Return:Q", format="$.2f")]
)


# Combine the pie chart with the center text
pie_chart_with_text = pie_return_chart + above_text + center_text + below_text
return_charts=alt.vconcat(bar_chart1,bar_chart2)

third_chart=pie_chart_with_text | return_charts
